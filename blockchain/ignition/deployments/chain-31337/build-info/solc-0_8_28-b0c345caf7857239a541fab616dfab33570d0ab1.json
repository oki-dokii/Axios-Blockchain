{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-b0c345caf7857239a541fab616dfab33570d0ab1",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/CarbonCreditMarketplace.sol": "project/contracts/CarbonCreditMarketplace.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/CarbonCreditMarketplace.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./CarbonCreditToken.sol\";\n\n/// @title CarbonCreditMarketplace - P2P marketplace for trading carbon credits\ncontract CarbonCreditMarketplace {\n    struct Listing {\n        address seller;\n        uint256 amount;\n        uint256 pricePerCredit; // in wei\n        bool active;\n        uint256 timestamp;\n    }\n\n    CarbonCreditToken public creditToken;\n    address public owner;\n    uint256 public feePercentage; // basis points (100 = 1%)\n    uint256 public constant MAX_FEE = 1000; // 10%\n\n    uint256 public listingCount;\n    mapping(uint256 => Listing) public listings;\n    mapping(address => uint256[]) public sellerListings;\n\n    event ListingCreated(uint256 indexed listingId, address indexed seller, uint256 amount, uint256 pricePerCredit);\n    event ListingCancelled(uint256 indexed listingId);\n    event PurchaseExecuted(uint256 indexed listingId, address indexed buyer, uint256 amount, uint256 totalPrice);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n\n    modifier onlySeller(uint256 listingId) {\n        require(listings[listingId].seller == msg.sender, \"only seller\");\n        _;\n    }\n\n    constructor(address tokenAddress, uint256 initialFee) {\n        require(tokenAddress != address(0), \"token address 0\");\n        require(initialFee <= MAX_FEE, \"fee too high\");\n        owner = msg.sender;\n        creditToken = CarbonCreditToken(tokenAddress);\n        feePercentage = initialFee;\n    }\n\n    function setFee(uint256 newFee) external onlyOwner {\n        require(newFee <= MAX_FEE, \"fee too high\");\n        feePercentage = newFee;\n    }\n\n    function createListing(uint256 amount, uint256 pricePerCredit) external returns (uint256) {\n        require(amount > 0, \"amount > 0\");\n        require(pricePerCredit > 0, \"price > 0\");\n        require(creditToken.balanceOf(msg.sender) >= amount, \"insufficient balance\");\n\n        // Transfer tokens to marketplace (escrow)\n        require(creditToken.transferFrom(msg.sender, address(this), amount), \"transfer failed\");\n\n        uint256 listingId = ++listingCount;\n        listings[listingId] = Listing({\n            seller: msg.sender,\n            amount: amount,\n            pricePerCredit: pricePerCredit,\n            active: true,\n            timestamp: block.timestamp\n        });\n\n        sellerListings[msg.sender].push(listingId);\n\n        emit ListingCreated(listingId, msg.sender, amount, pricePerCredit);\n        return listingId;\n    }\n\n    function purchase(uint256 listingId, uint256 amount) external payable {\n        Listing storage listing = listings[listingId];\n        require(listing.active, \"listing inactive\");\n        require(listing.amount >= amount, \"insufficient listing\");\n        require(msg.sender != listing.seller, \"cannot buy own\");\n\n        uint256 totalPrice = amount * listing.pricePerCredit;\n        require(msg.value >= totalPrice, \"insufficient payment\");\n\n        // Calculate fees\n        uint256 fee = (totalPrice * feePercentage) / 10000;\n        uint256 sellerAmount = totalPrice - fee;\n\n        // Transfer tokens to buyer\n        require(creditToken.transfer(msg.sender, amount), \"token transfer failed\");\n\n        // Transfer payment to seller\n        payable(listing.seller).transfer(sellerAmount);\n\n        // Refund excess payment\n        if (msg.value > totalPrice) {\n            payable(msg.sender).transfer(msg.value - totalPrice);\n        }\n\n        // Update listing\n        listing.amount -= amount;\n        if (listing.amount == 0) {\n            listing.active = false;\n        }\n\n        emit PurchaseExecuted(listingId, msg.sender, amount, totalPrice);\n    }\n\n    function cancelListing(uint256 listingId) external onlySeller(listingId) {\n        Listing storage listing = listings[listingId];\n        require(listing.active, \"already cancelled\");\n\n        listing.active = false;\n        \n        // Return tokens to seller\n        require(creditToken.transfer(listing.seller, listing.amount), \"return failed\");\n\n        emit ListingCancelled(listingId);\n    }\n\n    function getListing(uint256 listingId) external view returns (\n        address seller,\n        uint256 amount,\n        uint256 pricePerCredit,\n        bool active,\n        uint256 timestamp\n    ) {\n        Listing storage listing = listings[listingId];\n        require(listing.seller != address(0), \"listing not found\");\n        return (\n            listing.seller,\n            listing.amount,\n            listing.pricePerCredit,\n            listing.active,\n            listing.timestamp\n        );\n    }\n\n    function getSellerListings(address seller) external view returns (uint256[] memory) {\n        return sellerListings[seller];\n    }\n\n    function withdrawFees() external onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"no fees\");\n        payable(owner).transfer(balance);\n    }\n\n    receive() external payable {\n        // Allow contract to receive ETH\n    }\n}\n\n"
      },
      "project/contracts/CarbonCreditToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/// @title CarbonCreditToken - Minimal ERC20-compatible token with controlled minting\ncontract CarbonCreditToken {\n    string public name = \"Carbon Credit\";\n    string public symbol = \"CCT\";\n    uint8 public immutable decimals = 18;\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    address public minter; // EcoLedger or admin allowed to mint\n    address public owner;  // contract owner who can set minter\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event MinterUpdated(address indexed newMinter);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"only minter\");\n        _;\n    }\n\n    constructor(address initialOwner, address initialMinter) {\n        require(initialOwner != address(0), \"owner 0\");\n        owner = initialOwner;\n        minter = initialMinter;\n        emit MinterUpdated(initialMinter);\n    }\n\n    function setMinter(address newMinter) external onlyOwner {\n        minter = newMinter;\n        emit MinterUpdated(newMinter);\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) external returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n        require(allowed >= amount, \"insufficient allowance\");\n        if (allowed != type(uint256).max) {\n            allowance[from][msg.sender] = allowed - amount;\n            emit Approval(from, msg.sender, allowance[from][msg.sender]);\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function mint(address to, uint256 amount) external onlyMinter {\n        require(to != address(0), \"mint to 0\");\n        totalSupply += amount;\n        balanceOf[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal {\n        require(to != address(0), \"to 0\");\n        uint256 bal = balanceOf[from];\n        require(bal >= amount, \"insufficient balance\");\n        unchecked {\n            balanceOf[from] = bal - amount;\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }\n}\n\n\n"
      }
    }
  }
}