{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-810b7f2ae219d9c8c707bc1513f31d287017b715",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/EcoLedger.sol": "project/contracts/EcoLedger.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/CarbonCreditToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/// @title CarbonCreditToken - Minimal ERC20-compatible token with controlled minting\ncontract CarbonCreditToken {\n    string public name = \"Carbon Credit\";\n    string public symbol = \"CCT\";\n    uint8 public immutable decimals = 18;\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    address public minter; // EcoLedger or admin allowed to mint\n    address public owner;  // contract owner who can set minter\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event MinterUpdated(address indexed newMinter);\n    event Burn(address indexed from, uint256 value);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"only minter\");\n        _;\n    }\n\n    constructor(address initialOwner, address initialMinter) {\n        require(initialOwner != address(0), \"owner 0\");\n        owner = initialOwner;\n        minter = initialMinter;\n        emit MinterUpdated(initialMinter);\n    }\n\n    function setMinter(address newMinter) external onlyOwner {\n        minter = newMinter;\n        emit MinterUpdated(newMinter);\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) external returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n        require(allowed >= amount, \"insufficient allowance\");\n        if (allowed != type(uint256).max) {\n            allowance[from][msg.sender] = allowed - amount;\n            emit Approval(from, msg.sender, allowance[from][msg.sender]);\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function mint(address to, uint256 amount) external onlyMinter {\n        require(to != address(0), \"mint to 0\");\n        totalSupply += amount;\n        balanceOf[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    /// @notice Burn tokens (remove from supply permanently)\n    /// @param amount Amount of tokens to burn\n    function burn(uint256 amount) external {\n        require(balanceOf[msg.sender] >= amount, \"insufficient balance\");\n        unchecked {\n            balanceOf[msg.sender] -= amount;\n            totalSupply -= amount;\n        }\n        emit Burn(msg.sender, amount);\n        emit Transfer(msg.sender, address(0), amount);\n    }\n\n    /// @notice Burn tokens from another address (requires allowance)\n    /// @param from Address to burn tokens from\n    /// @param amount Amount of tokens to burn\n    function burnFrom(address from, uint256 amount) external {\n        uint256 allowed = allowance[from][msg.sender];\n        require(allowed >= amount, \"insufficient allowance\");\n        require(balanceOf[from] >= amount, \"insufficient balance\");\n        \n        if (allowed != type(uint256).max) {\n            allowance[from][msg.sender] = allowed - amount;\n            emit Approval(from, msg.sender, allowance[from][msg.sender]);\n        }\n        \n        unchecked {\n            balanceOf[from] -= amount;\n            totalSupply -= amount;\n        }\n        emit Burn(from, amount);\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal {\n        require(to != address(0), \"to 0\");\n        uint256 bal = balanceOf[from];\n        require(bal >= amount, \"insufficient balance\");\n        unchecked {\n            balanceOf[from] = bal - amount;\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }\n}\n\n\n"
      },
      "project/contracts/EcoBadgeNFT.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/// @title EcoBadgeNFT - Minimal ERC721-like NFT with baseURI metadata\ncontract EcoBadgeNFT {\n    string public name = \"EcoBadge\";\n    string public symbol = \"ECOB\";\n\n    string public baseURI;\n    address public owner;\n\n    mapping(uint256 => address) private _ownerOf;\n    mapping(address => uint256) private _balanceOf;\n    // naive owner enumeration for demo (not updated on transfers)\n    mapping(address => uint256[]) private _ownedTokens;\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    uint256 public nextId = 1;\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n\n    constructor(string memory base) {\n        owner = msg.sender;\n        baseURI = base;\n    }\n\n    function setBaseURI(string calldata base) external onlyOwner {\n        baseURI = base;\n    }\n\n    function tokenURI(uint256 id) public view returns (string memory) {\n        require(_ownerOf[id] != address(0), \"not minted\");\n        return string(abi.encodePacked(baseURI, _toString(id)));\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        require(account != address(0), \"zero addr\");\n        return _balanceOf[account];\n    }\n\n    function ownerOf(uint256 id) public view returns (address) {\n        address o = _ownerOf[id];\n        require(o != address(0), \"not minted\");\n        return o;\n    }\n\n    function approve(address spender, uint256 id) external {\n        address o = ownerOf(id);\n        require(msg.sender == o || isApprovedForAll[o][msg.sender], \"not authorized\");\n        getApproved[id] = spender;\n        emit Approval(o, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) external {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(address from, address to, uint256 id) public {\n        require(from == ownerOf(id), \"from not owner\");\n        require(to != address(0), \"to zero\");\n        require(\n            msg.sender == from ||\n            msg.sender == getApproved[id] ||\n            isApprovedForAll[from][msg.sender],\n            \"not authorized\"\n        );\n        delete getApproved[id];\n        _balanceOf[from] -= 1;\n        _balanceOf[to] += 1;\n        _ownerOf[id] = to;\n        emit Transfer(from, to, id);\n    }\n\n    function safeMint(address to) external onlyOwner returns (uint256) {\n        require(to != address(0), \"to zero\");\n        uint256 id = nextId++;\n        _ownerOf[id] = to;\n        _balanceOf[to] += 1;\n        _ownedTokens[to].push(id);\n        emit Transfer(address(0), to, id);\n        return id;\n    }\n\n    // minimal enumeration for frontend queries (not updated on transfer)\n    function tokenOfOwnerByIndex(address owner_, uint256 index) external view returns (uint256) {\n        require(index < _ownedTokens[owner_].length, \"index oob\");\n        return _ownedTokens[owner_][index];\n    }\n\n    function _toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) return \"0\";\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n\n\n"
      },
      "project/contracts/EcoLedger.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./CarbonCreditToken.sol\";\nimport \"./EcoBadgeNFT.sol\";\n\n/// @title EcoLedger - Logs eco actions, verifies them, and mints credits/badges\ncontract EcoLedger {\n    struct Action {\n        address company;\n        string title;\n        string description;\n        uint256 estimatedCredits;\n        string location;\n        bool verified;\n        uint256 actualCredits;\n    }\n\n    address public owner;\n    CarbonCreditToken public creditToken;\n    EcoBadgeNFT public badgeNFT;\n\n    uint256 public actionCount;\n    mapping(uint256 => Action) private _actions;\n\n    event EcoActionLogged(uint256 indexed actionId, address indexed company, string title);\n    event ActionVerified(uint256 indexed actionId, bool approved, uint256 credits);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n\n    constructor(address token, address badge) {\n        owner = msg.sender;\n        creditToken = CarbonCreditToken(token);\n        badgeNFT = EcoBadgeNFT(badge);\n    }\n\n    function logEcoAction(\n        string calldata title,\n        string calldata description,\n        uint256 estimatedCredits,\n        string calldata location\n    ) external returns (uint256) {\n        require(bytes(title).length > 0, \"title required\");\n        require(estimatedCredits > 0, \"estimate > 0\");\n        uint256 id = ++actionCount;\n        _actions[id] = Action({\n            company: msg.sender,\n            title: title,\n            description: description,\n            estimatedCredits: estimatedCredits,\n            location: location,\n            verified: false,\n            actualCredits: 0\n        });\n        emit EcoActionLogged(id, msg.sender, title);\n        return id;\n    }\n\n    function verifyAction(uint256 actionId, bool approved, uint256 actualCredits) external onlyOwner {\n        Action storage a = _actions[actionId];\n        require(a.company != address(0), \"no action\");\n        require(!a.verified, \"already verified\");\n        if (approved) {\n            require(actualCredits > 0, \"credits > 0\");\n            a.verified = true;\n            a.actualCredits = actualCredits;\n            creditToken.mint(a.company, actualCredits * 1e18);\n            // milestone example: mint a badge if >= 100 credits\n            if (actualCredits >= 100) {\n                badgeNFT.safeMint(a.company);\n            }\n        } else {\n            a.verified = true;\n            a.actualCredits = 0;\n        }\n        emit ActionVerified(actionId, approved, actualCredits);\n    }\n\n    function getAction(uint256 actionId)\n        external\n        view\n        returns (\n            string memory title,\n            string memory description,\n            uint256 estimatedCredits,\n            string memory location,\n            bool verified,\n            uint256 actualCredits\n        )\n    {\n        Action storage a = _actions[actionId];\n        require(a.company != address(0), \"no action\");\n        return (a.title, a.description, a.estimatedCredits, a.location, a.verified, a.actualCredits);\n    }\n}\n\n\n"
      }
    }
  }
}