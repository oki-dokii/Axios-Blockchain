{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-4f16f919321a8ef979ce05660285caa45b76c2a9",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Leaderboard.sol": "project/contracts/Leaderboard.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/AccessControl.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/// @title AccessControl - Role-based access control system\ncontract AccessControl {\n    enum Role {\n        NONE,\n        ADMIN,\n        VERIFIER,\n        MODERATOR\n    }\n\n    mapping(address => Role) public roles;\n    address public owner;\n\n    event RoleGranted(address indexed account, Role role);\n    event RoleRevoked(address indexed account, Role role);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n\n    modifier onlyRole(Role role) {\n        require(hasRole(msg.sender, role), \"missing role\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        roles[msg.sender] = Role.ADMIN;\n        emit RoleGranted(msg.sender, Role.ADMIN);\n    }\n\n    function hasRole(address account, Role role) public view returns (bool) {\n        return roles[account] == role;\n    }\n\n    function grantRole(address account, Role role) external onlyOwner {\n        require(account != address(0), \"zero address\");\n        require(role != Role.NONE, \"cannot grant NONE\");\n        \n        roles[account] = role;\n        emit RoleGranted(account, role);\n    }\n\n    function revokeRole(address account) external onlyOwner {\n        require(account != owner, \"cannot revoke owner\");\n        \n        roles[account] = Role.NONE;\n        emit RoleRevoked(account, Role.NONE);\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"zero address\");\n        require(newOwner != owner, \"same owner\");\n\n        address oldOwner = owner;\n        roles[oldOwner] = Role.NONE;\n        owner = newOwner;\n        roles[newOwner] = Role.ADMIN;\n\n        emit OwnershipTransferred(oldOwner, newOwner);\n        emit RoleRevoked(oldOwner, Role.NONE);\n        emit RoleGranted(newOwner, Role.ADMIN);\n    }\n}\n\n"
      },
      "project/contracts/CarbonCreditToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/// @title CarbonCreditToken - Minimal ERC20-compatible token with controlled minting\ncontract CarbonCreditToken {\n    string public name = \"Carbon Credit\";\n    string public symbol = \"CCT\";\n    uint8 public immutable decimals = 18;\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    address public minter; // EcoLedger or admin allowed to mint\n    address public owner;  // contract owner who can set minter\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event MinterUpdated(address indexed newMinter);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"only minter\");\n        _;\n    }\n\n    constructor(address initialOwner, address initialMinter) {\n        require(initialOwner != address(0), \"owner 0\");\n        owner = initialOwner;\n        minter = initialMinter;\n        emit MinterUpdated(initialMinter);\n    }\n\n    function setMinter(address newMinter) external onlyOwner {\n        minter = newMinter;\n        emit MinterUpdated(newMinter);\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) external returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n        require(allowed >= amount, \"insufficient allowance\");\n        if (allowed != type(uint256).max) {\n            allowance[from][msg.sender] = allowed - amount;\n            emit Approval(from, msg.sender, allowance[from][msg.sender]);\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function mint(address to, uint256 amount) external onlyMinter {\n        require(to != address(0), \"mint to 0\");\n        totalSupply += amount;\n        balanceOf[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal {\n        require(to != address(0), \"to 0\");\n        uint256 bal = balanceOf[from];\n        require(bal >= amount, \"insufficient balance\");\n        unchecked {\n            balanceOf[from] = bal - amount;\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }\n}\n\n\n"
      },
      "project/contracts/EcoBadgeNFT.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/// @title EcoBadgeNFT - Minimal ERC721-like NFT with baseURI metadata\ncontract EcoBadgeNFT {\n    string public name = \"EcoBadge\";\n    string public symbol = \"ECOB\";\n\n    string public baseURI;\n    address public owner;\n\n    mapping(uint256 => address) private _ownerOf;\n    mapping(address => uint256) private _balanceOf;\n    // naive owner enumeration for demo (not updated on transfers)\n    mapping(address => uint256[]) private _ownedTokens;\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    uint256 public nextId = 1;\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n\n    constructor(string memory base) {\n        owner = msg.sender;\n        baseURI = base;\n    }\n\n    function setBaseURI(string calldata base) external onlyOwner {\n        baseURI = base;\n    }\n\n    function tokenURI(uint256 id) public view returns (string memory) {\n        require(_ownerOf[id] != address(0), \"not minted\");\n        return string(abi.encodePacked(baseURI, _toString(id)));\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        require(account != address(0), \"zero addr\");\n        return _balanceOf[account];\n    }\n\n    function ownerOf(uint256 id) public view returns (address) {\n        address o = _ownerOf[id];\n        require(o != address(0), \"not minted\");\n        return o;\n    }\n\n    function approve(address spender, uint256 id) external {\n        address o = ownerOf(id);\n        require(msg.sender == o || isApprovedForAll[o][msg.sender], \"not authorized\");\n        getApproved[id] = spender;\n        emit Approval(o, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) external {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(address from, address to, uint256 id) public {\n        require(from == ownerOf(id), \"from not owner\");\n        require(to != address(0), \"to zero\");\n        require(\n            msg.sender == from ||\n            msg.sender == getApproved[id] ||\n            isApprovedForAll[from][msg.sender],\n            \"not authorized\"\n        );\n        delete getApproved[id];\n        _balanceOf[from] -= 1;\n        _balanceOf[to] += 1;\n        _ownerOf[id] = to;\n        emit Transfer(from, to, id);\n    }\n\n    function safeMint(address to) external onlyOwner returns (uint256) {\n        require(to != address(0), \"to zero\");\n        uint256 id = nextId++;\n        _ownerOf[id] = to;\n        _balanceOf[to] += 1;\n        _ownedTokens[to].push(id);\n        emit Transfer(address(0), to, id);\n        return id;\n    }\n\n    // minimal enumeration for frontend queries (not updated on transfer)\n    function tokenOfOwnerByIndex(address owner_, uint256 index) external view returns (uint256) {\n        require(index < _ownedTokens[owner_].length, \"index oob\");\n        return _ownedTokens[owner_][index];\n    }\n\n    function _toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) return \"0\";\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n\n\n"
      },
      "project/contracts/EcoLedgerV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./CarbonCreditToken.sol\";\nimport \"./EcoBadgeNFT.sol\";\nimport \"./AccessControl.sol\";\nimport \"./Leaderboard.sol\";\n\n/// @title EcoLedgerV2 - Enhanced ledger with multi-verifier and reputation system\ncontract EcoLedgerV2 {\n    struct Action {\n        address company;\n        string title;\n        string description;\n        uint256 estimatedCredits;\n        string location;\n        bool verified;\n        uint256 actualCredits;\n        uint256 verificationCount;\n        mapping(address => bool) verifiers;\n        uint256 timestamp;\n        string category; // e.g., \"renewable_energy\", \"tree_planting\", \"recycling\"\n    }\n\n    struct CompanyProfile {\n        uint256 totalCreditsEarned;\n        uint256 totalActions;\n        uint256 verifiedActions;\n        uint256 reputationScore; // 0-1000\n        bool isVerified;\n    }\n\n    AccessControl public accessControl;\n    CarbonCreditToken public creditToken;\n    EcoBadgeNFT public badgeNFT;\n    Leaderboard public leaderboard; // Optional - can be set after deployment\n\n    uint256 public actionCount;\n    mapping(uint256 => Action) private _actions;\n    mapping(address => CompanyProfile) public companies;\n    mapping(address => uint256[]) public companyActions;\n\n    uint256 public verificationThreshold; // number of verifications needed\n    uint256 public reputationMultiplier; // basis points (100 = 1x)\n\n    event EcoActionLogged(\n        uint256 indexed actionId,\n        address indexed company,\n        string title,\n        string category\n    );\n    event ActionVerified(\n        uint256 indexed actionId,\n        address indexed verifier,\n        bool approved,\n        uint256 credits\n    );\n    event ActionFullyVerified(\n        uint256 indexed actionId,\n        uint256 actualCredits\n    );\n    event CompanyVerified(address indexed company);\n    event ReputationUpdated(address indexed company, uint256 newScore);\n\n    modifier onlyRole(AccessControl.Role role) {\n        require(accessControl.hasRole(msg.sender, role), \"missing role\");\n        _;\n    }\n\n    constructor(\n        address tokenAddress,\n        address badgeAddress,\n        address accessControlAddress,\n        uint256 threshold\n    ) {\n        require(tokenAddress != address(0), \"token address 0\");\n        require(badgeAddress != address(0), \"badge address 0\");\n        require(accessControlAddress != address(0), \"access control address 0\");\n        \n        creditToken = CarbonCreditToken(tokenAddress);\n        badgeNFT = EcoBadgeNFT(badgeAddress);\n        accessControl = AccessControl(accessControlAddress);\n        verificationThreshold = threshold > 0 ? threshold : 1;\n        reputationMultiplier = 10000; // 1x default\n    }\n\n    function setVerificationThreshold(uint256 newThreshold) external onlyRole(AccessControl.Role.ADMIN) {\n        require(newThreshold > 0, \"threshold > 0\");\n        verificationThreshold = newThreshold;\n    }\n\n    function setReputationMultiplier(uint256 newMultiplier) external onlyRole(AccessControl.Role.ADMIN) {\n        require(newMultiplier <= 20000, \"multiplier too high\"); // max 2x\n        reputationMultiplier = newMultiplier;\n    }\n\n    function setLeaderboard(address leaderboardAddress) external onlyRole(AccessControl.Role.ADMIN) {\n        require(leaderboardAddress != address(0), \"zero address\");\n        leaderboard = Leaderboard(leaderboardAddress);\n    }\n\n    function logEcoAction(\n        string calldata title,\n        string calldata description,\n        uint256 estimatedCredits,\n        string calldata location,\n        string calldata category\n    ) external returns (uint256) {\n        require(bytes(title).length > 0, \"title required\");\n        require(estimatedCredits > 0, \"estimate > 0\");\n        require(bytes(category).length > 0, \"category required\");\n\n        uint256 id = ++actionCount;\n        Action storage action = _actions[id];\n        \n        action.company = msg.sender;\n        action.title = title;\n        action.description = description;\n        action.estimatedCredits = estimatedCredits;\n        action.location = location;\n        action.verified = false;\n        action.actualCredits = 0;\n        action.verificationCount = 0;\n        action.timestamp = block.timestamp;\n        action.category = category;\n\n        CompanyProfile storage profile = companies[msg.sender];\n        profile.totalActions++;\n\n        companyActions[msg.sender].push(id);\n\n        emit EcoActionLogged(id, msg.sender, title, category);\n        return id;\n    }\n\n    function verifyAction(\n        uint256 actionId,\n        bool approved,\n        uint256 actualCredits\n    ) external onlyRole(AccessControl.Role.VERIFIER) {\n        Action storage action = _actions[actionId];\n        require(action.company != address(0), \"action not found\");\n        require(!action.verifiers[msg.sender], \"already verified\");\n        require(!action.verified || !approved, \"action fully verified\");\n\n        action.verifiers[msg.sender] = true;\n\n        if (approved) {\n            require(actualCredits > 0, \"credits > 0\");\n            action.verificationCount++;\n            \n            // If threshold reached, finalize verification\n            if (action.verificationCount >= verificationThreshold && !action.verified) {\n                _finalizeVerification(actionId, actualCredits);\n            } else {\n                emit ActionVerified(actionId, msg.sender, true, actualCredits);\n            }\n        } else {\n            emit ActionVerified(actionId, msg.sender, false, 0);\n        }\n    }\n\n    function _finalizeVerification(uint256 actionId, uint256 baseCredits) internal {\n        Action storage action = _actions[actionId];\n        require(!action.verified, \"already verified\");\n\n        CompanyProfile storage profile = companies[action.company];\n\n        // Apply reputation multiplier\n        uint256 adjustedCredits = (baseCredits * reputationMultiplier) / 10000;\n        action.actualCredits = adjustedCredits;\n        action.verified = true;\n\n        // Update company profile\n        profile.totalCreditsEarned += adjustedCredits;\n        profile.verifiedActions++;\n        _updateReputation(action.company);\n\n        // Mint credits\n        creditToken.mint(action.company, adjustedCredits * 1e18);\n\n        // Update leaderboard if set\n        if (address(leaderboard) != address(0)) {\n            leaderboard.updateLeaderboard(action.company);\n        }\n\n        // Mint badges based on milestones\n        if (profile.totalCreditsEarned >= 1000 && profile.totalCreditsEarned - adjustedCredits < 1000) {\n            badgeNFT.safeMint(action.company);\n        }\n        if (profile.totalCreditsEarned >= 5000 && profile.totalCreditsEarned - adjustedCredits < 5000) {\n            badgeNFT.safeMint(action.company);\n        }\n        if (profile.totalCreditsEarned >= 10000 && profile.totalCreditsEarned - adjustedCredits < 10000) {\n            badgeNFT.safeMint(action.company);\n        }\n\n        emit ActionFullyVerified(actionId, adjustedCredits);\n    }\n\n    function verifyCompany(address company) external onlyRole(AccessControl.Role.ADMIN) {\n        require(company != address(0), \"zero address\");\n        companies[company].isVerified = true;\n        emit CompanyVerified(company);\n    }\n\n    function _updateReputation(address company) internal {\n        CompanyProfile storage profile = companies[company];\n        \n        if (profile.totalActions == 0) {\n            profile.reputationScore = 0;\n            return;\n        }\n\n        // Calculate reputation: verified ratio * 500 + credits tier * 500\n        uint256 verifiedRatio = (profile.verifiedActions * 1000) / profile.totalActions;\n        uint256 creditsTier = profile.totalCreditsEarned > 10000 ? 1000 :\n                             profile.totalCreditsEarned > 5000 ? 750 :\n                             profile.totalCreditsEarned > 1000 ? 500 :\n                             profile.totalCreditsEarned > 100 ? 250 : 0;\n        \n        profile.reputationScore = (verifiedRatio * 500) / 1000 + creditsTier;\n        \n        if (profile.reputationScore > 1000) profile.reputationScore = 1000;\n\n        emit ReputationUpdated(company, profile.reputationScore);\n    }\n\n    function getAction(uint256 actionId)\n        external\n        view\n        returns (\n            address company,\n            string memory title,\n            string memory description,\n            uint256 estimatedCredits,\n            string memory location,\n            bool verified,\n            uint256 actualCredits,\n            uint256 verificationCount,\n            uint256 timestamp,\n            string memory category\n        )\n    {\n        Action storage action = _actions[actionId];\n        require(action.company != address(0), \"action not found\");\n        \n        return (\n            action.company,\n            action.title,\n            action.description,\n            action.estimatedCredits,\n            action.location,\n            action.verified,\n            action.actualCredits,\n            action.verificationCount,\n            action.timestamp,\n            action.category\n        );\n    }\n\n    function getCompanyProfile(address company)\n        external\n        view\n        returns (\n            uint256 totalCreditsEarned,\n            uint256 totalActions,\n            uint256 verifiedActions,\n            uint256 reputationScore,\n            bool isVerified\n        )\n    {\n        CompanyProfile storage profile = companies[company];\n        return (\n            profile.totalCreditsEarned,\n            profile.totalActions,\n            profile.verifiedActions,\n            profile.reputationScore,\n            profile.isVerified\n        );\n    }\n\n    function getCompanyActions(address company) external view returns (uint256[] memory) {\n        return companyActions[company];\n    }\n\n    function hasVerified(uint256 actionId, address verifier) external view returns (bool) {\n        return _actions[actionId].verifiers[verifier];\n    }\n}\n\n"
      },
      "project/contracts/Leaderboard.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./EcoLedgerV2.sol\";\n\n/// @title Leaderboard - Ranking system for companies based on carbon credits\ncontract Leaderboard {\n    struct LeaderboardEntry {\n        address company;\n        uint256 totalCredits;\n        uint256 reputationScore;\n        uint256 rank;\n    }\n\n    EcoLedgerV2 public ecoLedger;\n    address public owner;\n\n    mapping(uint256 => address) public topCompanies; // rank => address\n    uint256 public topCount = 100; // Top 100 companies\n\n    event LeaderboardUpdated(address indexed company, uint256 rank, uint256 credits);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n\n    constructor(address ledgerAddress) {\n        require(ledgerAddress != address(0), \"ledger address 0\");\n        owner = msg.sender;\n        ecoLedger = EcoLedgerV2(ledgerAddress);\n    }\n\n    function updateLeaderboard(address company) external {\n        // Only allow ledger to update\n        require(msg.sender == address(ecoLedger), \"only ledger\");\n\n        (uint256 totalCredits, , , uint256 reputationScore, ) = ecoLedger.getCompanyProfile(company);\n        \n        // Simple ranking: find position and update\n        _updateRank(company, totalCredits, reputationScore);\n    }\n\n    function _updateRank(address company, uint256 credits, uint256 reputation) internal {\n        // Simple implementation: find where company should be ranked\n        // In production, use a more efficient data structure\n        \n        uint256 currentRank = _findRank(credits, reputation);\n        \n        if (currentRank <= topCount) {\n            // Shift companies down if needed\n            for (uint256 i = topCount; i > currentRank; i--) {\n                if (i > 1) {\n                    topCompanies[i] = topCompanies[i - 1];\n                }\n            }\n            \n            if (currentRank > 0 && currentRank <= topCount) {\n                topCompanies[currentRank] = company;\n                emit LeaderboardUpdated(company, currentRank, credits);\n            }\n        }\n    }\n\n    function _findRank(uint256 credits, uint256 reputation) internal view returns (uint256) {\n        uint256 score = credits + (reputation * 100); // Weighted score\n        \n        for (uint256 i = 1; i <= topCount; i++) {\n            address companyAtRank = topCompanies[i];\n            if (companyAtRank == address(0)) {\n                return i;\n            }\n            \n            (uint256 rankCredits, , , uint256 rankRep, ) = ecoLedger.getCompanyProfile(companyAtRank);\n            uint256 rankScore = rankCredits + (rankRep * 100);\n            \n            if (score > rankScore) {\n                return i;\n            }\n        }\n        \n        return topCount + 1; // Not in top 100\n    }\n\n    function getTopCompanies(uint256 limit) external view returns (LeaderboardEntry[] memory) {\n        require(limit > 0 && limit <= topCount, \"invalid limit\");\n        \n        LeaderboardEntry[] memory entries = new LeaderboardEntry[](limit);\n        \n        for (uint256 i = 1; i <= limit; i++) {\n            address company = topCompanies[i];\n            if (company == address(0)) break;\n            \n            (uint256 credits, , , uint256 reputation, ) = ecoLedger.getCompanyProfile(company);\n            \n            entries[i - 1] = LeaderboardEntry({\n                company: company,\n                totalCredits: credits,\n                reputationScore: reputation,\n                rank: i\n            });\n        }\n        \n        return entries;\n    }\n\n    function getCompanyRank(address company) external view returns (uint256) {\n        for (uint256 i = 1; i <= topCount; i++) {\n            if (topCompanies[i] == company) {\n                return i;\n            }\n        }\n        return 0; // Not ranked\n    }\n\n    function setTopCount(uint256 newCount) external onlyOwner {\n        require(newCount > 0 && newCount <= 1000, \"invalid count\");\n        topCount = newCount;\n    }\n}\n\n"
      }
    }
  }
}