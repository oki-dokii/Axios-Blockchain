{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-6872bf664b25f25625f34484bb4f72af87932a36",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/CreditStaking.sol": "project/contracts/CreditStaking.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/CarbonCreditToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/// @title CarbonCreditToken - Minimal ERC20-compatible token with controlled minting\ncontract CarbonCreditToken {\n    string public name = \"Carbon Credit\";\n    string public symbol = \"CCT\";\n    uint8 public immutable decimals = 18;\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    address public minter; // EcoLedger or admin allowed to mint\n    address public owner;  // contract owner who can set minter\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event MinterUpdated(address indexed newMinter);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"only minter\");\n        _;\n    }\n\n    constructor(address initialOwner, address initialMinter) {\n        require(initialOwner != address(0), \"owner 0\");\n        owner = initialOwner;\n        minter = initialMinter;\n        emit MinterUpdated(initialMinter);\n    }\n\n    function setMinter(address newMinter) external onlyOwner {\n        minter = newMinter;\n        emit MinterUpdated(newMinter);\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) external returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n        require(allowed >= amount, \"insufficient allowance\");\n        if (allowed != type(uint256).max) {\n            allowance[from][msg.sender] = allowed - amount;\n            emit Approval(from, msg.sender, allowance[from][msg.sender]);\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function mint(address to, uint256 amount) external onlyMinter {\n        require(to != address(0), \"mint to 0\");\n        totalSupply += amount;\n        balanceOf[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal {\n        require(to != address(0), \"to 0\");\n        uint256 bal = balanceOf[from];\n        require(bal >= amount, \"insufficient balance\");\n        unchecked {\n            balanceOf[from] = bal - amount;\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }\n}\n\n\n"
      },
      "project/contracts/CreditStaking.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./CarbonCreditToken.sol\";\n\n/// @title CreditStaking - Staking mechanism for carbon credits with rewards\ncontract CreditStaking {\n    struct Stake {\n        uint256 amount;\n        uint256 timestamp;\n        uint256 lockPeriod; // in seconds\n        bool isLocked;\n    }\n\n    CarbonCreditToken public creditToken;\n    address public owner;\n    address public minter; // Address that can mint rewards (should be set to this contract or a reward pool)\n    \n    uint256 public rewardRate; // basis points per year (100 = 1%)\n    uint256 public constant BASIS_POINTS = 10000;\n    uint256 public constant MAX_REWARD_RATE = 5000; // 50% max\n    \n    mapping(address => Stake[]) public stakes;\n    mapping(address => uint256) public totalStaked;\n    mapping(address => uint256) public totalRewards;\n    \n    uint256 public totalStakedAmount;\n    uint256 public totalRewardsDistributed;\n\n    event Staked(address indexed user, uint256 indexed stakeId, uint256 amount, uint256 lockPeriod);\n    event Unstaked(address indexed user, uint256 indexed stakeId, uint256 amount, uint256 reward);\n    event RewardClaimed(address indexed user, uint256 amount);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n\n    constructor(address tokenAddress, uint256 initialRewardRate) {\n        require(tokenAddress != address(0), \"token address 0\");\n        require(initialRewardRate <= MAX_REWARD_RATE, \"rate too high\");\n        owner = msg.sender;\n        creditToken = CarbonCreditToken(tokenAddress);\n        rewardRate = initialRewardRate;\n        // Note: minter should be set to this contract address after deployment\n        // using creditToken.setMinter(address(this))\n    }\n\n    function setMinter(address newMinter) external onlyOwner {\n        minter = newMinter;\n    }\n\n    function setRewardRate(uint256 newRate) external onlyOwner {\n        require(newRate <= MAX_REWARD_RATE, \"rate too high\");\n        rewardRate = newRate;\n    }\n\n    function stake(uint256 amount, uint256 lockPeriodInDays) external {\n        require(amount > 0, \"amount > 0\");\n        require(lockPeriodInDays > 0, \"lock period > 0\");\n        require(creditToken.balanceOf(msg.sender) >= amount, \"insufficient balance\");\n\n        // Transfer tokens to staking contract\n        require(creditToken.transferFrom(msg.sender, address(this), amount), \"transfer failed\");\n\n        uint256 lockPeriod = lockPeriodInDays * 1 days;\n        \n        stakes[msg.sender].push(Stake({\n            amount: amount,\n            timestamp: block.timestamp,\n            lockPeriod: lockPeriod,\n            isLocked: true\n        }));\n\n        totalStaked[msg.sender] += amount;\n        totalStakedAmount += amount;\n\n        emit Staked(msg.sender, stakes[msg.sender].length - 1, amount, lockPeriod);\n    }\n\n    function unstake(uint256 stakeIndex) external {\n        require(stakeIndex < stakes[msg.sender].length, \"invalid index\");\n        \n        Stake storage userStake = stakes[msg.sender][stakeIndex];\n        require(userStake.isLocked, \"already unstaked\");\n        require(\n            block.timestamp >= userStake.timestamp + userStake.lockPeriod,\n            \"still locked\"\n        );\n\n        uint256 stakedAmount = userStake.amount;\n        uint256 reward = calculateReward(userStake);\n        \n        userStake.isLocked = false;\n        totalStaked[msg.sender] -= stakedAmount;\n        totalStakedAmount -= stakedAmount;\n\n        // Mint reward tokens (requires this contract to be set as minter)\n        if (minter == address(this)) {\n            creditToken.mint(msg.sender, reward);\n        } else if (minter != address(0)) {\n            // If minter is set to another address (e.g., ledger), transfer from there\n            require(creditToken.transferFrom(minter, msg.sender, reward), \"reward transfer failed\");\n        } else {\n            // No minter set - skip rewards or revert\n            // For now, we'll skip rewards if minter not configured\n            reward = 0;\n        }\n        \n        // Transfer staked tokens back\n        require(creditToken.transfer(msg.sender, stakedAmount), \"transfer failed\");\n\n        totalRewards[msg.sender] += reward;\n        totalRewardsDistributed += reward;\n\n        emit Unstaked(msg.sender, stakeIndex, stakedAmount, reward);\n    }\n\n    function calculateReward(Stake memory stakeData) public view returns (uint256) {\n        if (!stakeData.isLocked || block.timestamp < stakeData.timestamp + stakeData.lockPeriod) {\n            return 0;\n        }\n\n        uint256 stakingDuration = block.timestamp - stakeData.timestamp;\n        uint256 annualReward = (stakeData.amount * rewardRate) / BASIS_POINTS;\n        uint256 reward = (annualReward * stakingDuration) / 365 days;\n\n        return reward;\n    }\n\n    function getStakeCount(address user) external view returns (uint256) {\n        return stakes[user].length;\n    }\n\n    function getStake(address user, uint256 index) external view returns (\n        uint256 amount,\n        uint256 timestamp,\n        uint256 lockPeriod,\n        bool isLocked,\n        uint256 pendingReward\n    ) {\n        require(index < stakes[user].length, \"invalid index\");\n        Stake memory stakeData = stakes[user][index];\n        uint256 reward = 0;\n        \n        if (stakeData.isLocked && block.timestamp >= stakeData.timestamp + stakeData.lockPeriod) {\n            reward = calculateReward(stakeData);\n        }\n\n        return (\n            stakeData.amount,\n            stakeData.timestamp,\n            stakeData.lockPeriod,\n            stakeData.isLocked,\n            reward\n        );\n    }\n\n    function getTotalPendingRewards(address user) external view returns (uint256) {\n        uint256 total = 0;\n        for (uint256 i = 0; i < stakes[user].length; i++) {\n            if (stakes[user][i].isLocked) {\n                Stake memory stakeData = stakes[user][i];\n                if (block.timestamp >= stakeData.timestamp + stakeData.lockPeriod) {\n                    total += calculateReward(stakeData);\n                }\n            }\n        }\n        return total;\n    }\n}\n\n"
      }
    }
  }
}